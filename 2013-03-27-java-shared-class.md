# 2013-03-27-java-shared-class

共享类特性是从头设计的，它是一个可以打开和关闭的选项，可以减少虚拟内存占用并改进 JVM 启动时间。因此，__它非常适合多个 JVM 运行相似代码的环境或者 JVM 常常重新启动的环境。__

#####1 类缓存
类缓存是一个大小固定的共享内存区，它在使用它的 JVM 的生命周期之外仍然持久地存在。一个系统上可以有任意数量的共享类缓存，这只受操作系统设置的限制；__但是一个 JVM 在它的生命周期中只能连接一个缓存。__

<!-- more -->

JVM 并不拥有缓存，也没有 主/从 JVM 的概念；实际上，任意数量的 JVM 都可以并行地读写缓存。在两种情况下会删除缓存：

* 使用 JVM 实用程序显式地销毁它
* 或者操作系统重新启动时（缓存无法在操作系统重新启动时持久存在）。

缓存的大小无法增长，当它被填满时，JVM 仍然可以从其中装载类，但是不能再向其中添加任何类。

#####2 如何缓存类
当 JVM 装载一个类时，它先查看需要的类是否已经在缓存中存在。如果是这样，那么它从缓存装载这个类。否则，它从文件系统装载这个类并将其写到缓存中（在 defineClass() 调用中进行这一操作）。

不进行共享的 JVM 采用以下类装载器查找次序：

```
类装载器缓存
父类装载器
文件系统
```

进行共享的 JVM 采用以下次序：

```
__类装载器缓存__
父类装载器
__共享缓存__
文件系统
```

#####3 缓存类的哪些部分
在 JVM 的 IBM 实现中，Java 类分成两个部分：

* 一个称为 ROMClass 的只读部分，其中包含不可变的所有类数据；
* 一个 RAMClass 部分，其中包含可变的数据，比如静态类变量。

RAMClass 指向 ROMClass 中的数据，但是这两部分是完全分开的，这意味着 ROMClass 可以十分安全地在 JVM 之间共享，甚至在同一个 JVM 中的 RAMClass 之间共享。

#####4 共享类好处

* 因为大部分类数据存储在 ROMClass 中，因此可以节省虚拟内存；
* 已经填充的缓存还会显著改进 JVM 启动时间，因为每个缓存的类的一部分定义工作已经完成了，而且会从内存装载类而不是从文件系统装载；
* 填充新缓存导致的启动时间开销并不显著，因为每个类只需在定义时重新定位到缓存中；

#####5 如果文件系统中的类发生变化
因为缓存是无限期持久存在的，文件系统更新可能会使缓存中的类失效。因此，当类装载器请求一个共享的类时，缓存代码要负责确保返回的类总是与从文件系统装载的类完全一样。当装载类时这一检查会透明地进行，所以用户可以在共享类缓存的生命周期内修改和更新任意类，系统总会装载正确的类。

JVM 探测文件系统更新的方法是，将时间戳值存储在缓存中并在装载每个类时比较缓存的值和实际值。如果它探测到一个 JAR 文件已经更新了，那么它不知道哪些类已经更新了，所以缓存中所有从这个 JAR 装载的类都立即被标为过时的，不能再从缓存中装载它们。当从文件系统装载这个 JAR 中的类并重新添加到缓存中时，只添加实际修改过的类；那些没有修改的类实际上没有过时。


