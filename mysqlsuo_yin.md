# MySQL索引

[MySQL索引背后的数据结构及算法原理](http://blog.jobbole.com/24006/#rd?sukey=c65e39fee5582111f38892d43cba7aeaf9ebe51e6f9f7b4909053af203d7cc8744c963a8745f4519f7f89b011e568c53)

讲的内容基本就是`高性能MySQL`里面的内容。


## InnoDB

### 数据存储

使用`聚集索引`，索引和数据在一起。

### 优点

* 索引和数据在一起，如果访问数据是连续的，可以一次把相关`索引和数据`都加载到内存
* 使用的`聚集索引`，数据访问快，索引和数据在一起，访问速度比`非聚集索引`快

### 缺点

* 严重依赖插入顺序，按照主键顺序进行数据插入是最快的方法。索引主键都必须要设置为`自增长ID`
* 聚集索引的更新是昂贵的，由于B+树的特性，他涉及到频繁的分裂调整，十分低效
* 分页导致占用更多的磁盘空间
* Secondary Key访问数据需要进行两次索引查找（第一次，在SecondaryKey索引结构中，找到`主键的值`，第二次，在聚集索引中，找到数据，进行了两次的BTree的查找过程）

## MyISAM

### 数据存储

使用`非聚集索引`，索引和数据分开存储。索引的叶子节点的data，存储的是真实数据的地址

### 优点

### 缺点


## 以自增长ID为主键

只考虑通过主键进行操作，不考虑有额外索引的情况，其实都类似

|  | 增 | 删 | 改 | 查 |
| -- | -- | -- | -- | -- |
| InnoDB | 插入主键+数据到BTree | 一次BTree存查找，数据删除 | 一次BTree查找，数据更新 | 做一次BTree查找 |
| MyISAM | 写数据，插入主键到BTree种 | 一次BTree查找，一次内存寻址，数据删除 | 一次BTree查找，一次内存寻址，数据更新 | 进行一次BTree查找，一次内存寻址 |
| 备注 | BTree在插入过程中，会涉及到分页，分页就涉及到数据移动，InnoDB会有更多的数据移动 | InnoDB更快  | InnoDB更快 | InnoDB更快 |


## 以非自增长ID为主键

只考虑通过主键进行操作，不考虑有额外索引的情况，其实都类似

|  | 增 | 删 | 改 | 查 |
| -- | -- | -- | -- | -- |
| InnoDB | 同上 | 同上 | 同上 | 同上 |
| MyISAM | 同上 | 同上 | 同上 | 同上 |
| 备注 | 由于BTree的分裂调整，会有比分页更多的数据移动，而InnoDB移动的数据量大多了。 |  | 3:2 | 的 |