# JAVA基础


### 抽象和接口

[深入理解Java的接口和抽象类](http://www.cnblogs.com/dolphin0520/p/3811437.html)

1.语法层面上的区别

* 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
* 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
* 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
* 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2.设计层面上的区别

* 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

* 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

```
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

### 重载和重写

#### 重载（Overload）
  简单地说，就是允许多个同名但形参个数或类型不同的函数方法存在于一个类里面，当类以统一调用方式，由形参来决定调用具体方法！
  重载方法是通过形参的类型，个数，顺序来区分的，不是依靠形参的名字区分的，也不是依靠返回值区分的！  亦即返回值可以不同或相同。
  
#### 重写（Override）
  重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！
  
### final

效率、设计；数据、方法、类、参数。

[关键字final](http://www.cnblogs.com/chenssy/p/3428180.html)

[深入理解Java中的final关键字](http://www.importnew.com/7553.html)

下面总结了一些使用final关键字的好处：
* final关键字提高了性能。JVM和Java应用都会缓存final变量。
* final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
* 使用final关键字，JVM会对方法、变量及类进行优化。

### String类

[String Interning研究](http://blog.csdn.net/biaobiaoqi/article/details/6892352)

String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。

```
String str = new String("abc");
```
这里确实是有两个 String 对象生成了。

new String("xxx") 创建的 String 对象会在 heap 中重新生成新的 String 对象，绕过字符串池的管辖。而如果使用String str = "xxx"则先查看字符串池 是否已经存在，存在则直接返回 PermGen 中的该 String 对象，否则生成新的 String 对象，并将它加入字符串池中。

尽量使用`String str = "abc";`，而不是`String str = new String("abc")`；

[为什么String类是不可变的](http://www.importnew.com/7440.html)

### 变量的隐藏和覆盖

实例方法被覆盖，静态方法被隐藏

[java里的变量隐藏、方法覆盖、方法隐藏](http://justt0.iteye.com/blog/1944357)

* 变量：变量只会被隐藏，不能被覆盖，子类的实例变量/静态变量会隐藏父类同名的实例变量/静态变量，注意“/”这个符号，说明总共有4种隐藏方式。
* 方法：方法有两种方式，被隐藏/覆盖，同名的静态方法被隐藏，同名的实例方法被覆盖，交叉的形式会报错。

### 构造函数相关

[Java构造时成员初始化的陷阱](http://coolshell.cn/articles/1106.html)

在面向对象的世界中，因为程序以对象的形式出现，导致了我们对程序执行的顺序雾里看花。所以，在面向对象的世界中，程序执行的顺序相当的重要。

下面是对上面各个步骤的逐条解释：

* 进入构造函数。
* 为成员变量分配内存。
* 除非你显式地调用super()，否则Java 会在子类的构造函数最前面偷偷地插入super() 。
* 调用父类构造函数。
* 调用preProcess，因为被子类override，所以调用的是子类的。
* 于是，初始化发生在了preProcess()之后。这是因为，Java需要保证父类的初始化早于子类的成员初始化，否则，在子类中使用父类的成员变量就会出现问题。
* 正式执行子类的构造函数（当然这是一个空函数，虽然我们没有声明）。

[JAVA对象初始化详解](http://blog.jobbole.com/23939/)

Java要求一个对象被初始化之前，其超类也必须被初始化，这一点是在构造函数中保证的`。Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们即没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用指令。

一个实例变量，在对象初始化过程中，可能被赋值四次：
  * 分配内存的时候
  * 实例变量初始化器：private int i = 1;
  * 实例初始化器：
  * 构造函数

一个类，在第一次使用的时候会被初始化，而且只会被一个线程初始化一次。我们可以通过`静态初始化器`和`静态变量初始化器`来完成对类变量的初始化工作。


### switch case

* 1.default就是如果没有符合的case就执行它,default并不是必须的. 
* 2.case后的语句可以不用大括号. 
* 3.switch语句的判断条件可以接受int,byte,char,short,不能接受其他类型. 
* 4.`一旦case匹配,就会顺序执行后面的程序代码,而不管后面的case是否匹配,直到遇见break`,利用这一特性可以让好几个case执行统一语句. 


### 线程安全的单例

完美的解决方案：[如何正确地写出单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)

[深入理解Java内存模型（一）——重排序](http://www.infoq.com/cn/articles/java-memory-model-1/)

[深入理解Java内存模型（二）——重排序](http://www.infoq.com/cn/articles/java-memory-model-2/)

[深入理解Java内存模型（三）——顺序一致性](http://www.infoq.com/cn/articles/java-memory-model-3/)

[深入理解Java内存模型（三）——volatile](http://www.infoq.com/cn/articles/java-memory-model-4/)

[深入理解Java内存模型（三）——锁](http://www.infoq.com/cn/articles/java-memory-model-5/)

[深入理解Java内存模型（三）——重排序](http://www.infoq.com/cn/articles/java-memory-model-6/)

[深入理解Java内存模型（三）——重排序](http://www.infoq.com/cn/articles/java-memory-model-7/)

### 异常相关

[Java异常处理和设计](http://www.cnblogs.com/dolphin0520/p/3769804.html)

![异常结构图](http://7xpmu3.com1.z0.glb.clouddn.com/JAVA_EXCEPTION.jpg)

对于`非运行时异常`如果不进行捕获或者抛出声明处理，或者在try-catch中声明了但是try中没有可能抛出相关异常的，编译都不会通过。

但是在try-catch中，如果声明了Exception，而且try中也没有可能抛出相关异常，编译可以通过。

#### try & catch & finally

三个块执行的顺序为try—>catch—>finally。

当然如果没有发生异常，则catch块不会执行。但是finally块无论在什么情况下都是会执行的（这点要非常注意，因此部分情况下，都会将释放资源的操作放在finally块中进行）。

在有多个catch块的时候，是按照catch块的先后顺序进行匹配的，一旦异常类型被一个catch块匹配，则不会与后面的catch块进行匹配。

在使用try..catch..finally块的时候，注意`千万不要在finally块中使用return，因为finally中的return会覆盖已有的返回值`。

#### throws和thow关键字

throws出现在方法的声明中，表示该方法可能会抛出的异常，然后交给上层调用它的方法程序处理，允许throws后面跟着多个异常类型；

throw只会出现在方法体中，当方法在执行过程中遇到异常情况时，将异常信息封装为异常对象，然后throw出去。throw关键字的一个非常重要的作用就是 异常类型的转换。

throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。

#### 子类重写父类方法的时候，如何确定异常抛出声明的类型

下面是三点原则：

　　1）父类的方法没有声明异常，子类在重写该方法的时候不能声明异常；

　　2）如果父类的方法声明一个异常exception1，则子类在重写该方法的时候声明的异常不能是exception1的父类；

　　3）如果父类的方法声明的异常类型只有非运行时异常（运行时异常），则子类在重写该方法的时候声明的异常也只能有非运行时异常（运行时异常），不能含有运行时异常（非运行时异常）。
  
#### 建议

* 只在必要使用异常的地方才使用异常，不要用异常去控制程序的流程
* 切忌使用空catch块
* 只在异常最开始发生的地方进行日志信息记录。很多情况下异常都是层层向上跑出的，如果在每次向上抛出的时候，都Log到日志系统中，则会导致无从查找异常发生的根源。
* 尽量将异常统一抛给上层调用者，由上层调用者统一之时如何进行处理。如果在每个出现异常的地方都直接进行处理，会导致程序异常处理流程混乱，不利于后期维护和异常错误排查。由上层统一进行处理会使得整个程序的流程清晰易懂。


### HashMap

[Java HashMap 分析](http://blog.csdn.net/csfreebird/article/details/7347026)

1：不要在并发场景中使用HashMap
    HashMap是线程不安全的，如果被多个线程共享的操作，将会引发不可预知的问题，据sun的说法，在扩容时，会引起链表的闭环，在get元素时，就会无限循环，后果是cpu100%。
    
2：如果数据大小是固定的，那么最好给HashMap设定一个合理的容量值
    根据上面的分析，HashMap的初始默认容量是16，默认加载因子是0.75，也就是说，如果采用HashMap的默认构造函数，当增加数据时，数据实 际容量超过10*0.75=12时，HashMap就扩容，扩容带来一系列的运算，新建一个是原来容量2倍的数组，对原有元素全部重新哈希，`如果你的数据 有几千几万个，而用默认的HashMap构造函数，那结果是非常悲剧的，因为HashMap不断扩容，不断哈希`，在使用HashMap的场景里，不会是多个线程共享一个HashMap,除非对HashMap包装并同步，由此产生的内存开销和cpu开销在某些情况下可能是致命的。