# JAVA基础


### 抽象和接口

[深入理解Java的接口和抽象类](http://www.cnblogs.com/dolphin0520/p/3811437.html)

1.语法层面上的区别

* 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
* 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
* 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
* 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2.设计层面上的区别

* 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

* 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

```
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

### 重载和重写

#### 重载（Overload）
  简单地说，就是允许多个同名但形参个数或类型不同的函数方法存在于一个类里面，当类以统一调用方式，由形参来决定调用具体方法！
  重载方法是通过形参的类型，个数，顺序来区分的，不是依靠形参的名字区分的，也不是依靠返回值区分的！  亦即返回值可以不同或相同。
  
#### 重写（Override）
  重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！
  
### final

效率、设计；数据、方法、类、参数。

[关键字final](http://www.cnblogs.com/chenssy/p/3428180.html)

[深入理解Java中的final关键字](http://www.importnew.com/7553.html)

下面总结了一些使用final关键字的好处：
* final关键字提高了性能。JVM和Java应用都会缓存final变量。
* final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
* 使用final关键字，JVM会对方法、变量及类进行优化。

### String类

String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。

[为什么String类是不可变的](http://www.importnew.com/7440.html)

### 变量的隐藏和覆盖

实例方法被覆盖，静态方法被隐藏

[java里的变量隐藏、方法覆盖、方法隐藏](http://justt0.iteye.com/blog/1944357)

* 变量：变量只会被隐藏，不能被覆盖，子类的实例变量/静态变量会隐藏父类同名的实例变量/静态变量，注意“/”这个符号，说明总共有4种隐藏方式。
* 方法：方法有两种方式，被隐藏/覆盖，同名的静态方法被隐藏，同名的实例方法被覆盖，交叉的形式会报错。

### 构造函数相关

[Java构造时成员初始化的陷阱](http://coolshell.cn/articles/1106.html)

在面向对象的世界中，因为程序以对象的形式出现，导致了我们对程序执行的顺序雾里看花。所以，在面向对象的世界中，程序执行的顺序相当的重要。

下面是对上面各个步骤的逐条解释：

* 进入构造函数。
* 为成员变量分配内存。
* 除非你显式地调用super()，否则Java 会在子类的构造函数最前面偷偷地插入super() 。
* 调用父类构造函数。
* 调用preProcess，因为被子类override，所以调用的是子类的。
* 于是，初始化发生在了preProcess()之后。这是因为，Java需要保证父类的初始化早于子类的成员初始化，否则，在子类中使用父类的成员变量就会出现问题。
* 正式执行子类的构造函数（当然这是一个空函数，虽然我们没有声明）。

[JAVA对象初始化详解](http://blog.jobbole.com/23939/)

Java要求一个对象被初始化之前，其超类也必须被初始化，这一点是在构造函数中保证的`。Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们即没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用指令。

  一个实例变量，在对象初始化过程中，可能被赋值四次：
  * 1. 分配内存的时候
  * 2. 实例变量初始化器：private int i = 1;
  * 3. 实例初始化器：
  * 4. 构造函数

